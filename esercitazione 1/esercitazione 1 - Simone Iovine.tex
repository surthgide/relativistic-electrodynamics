% Esercitazione 1 di Elettrodinamica relativistica di Simone Iovine

\documentclass[12pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{datetime}
\usepackage{amsthm,amssymb,amsmath}
\usepackage{mathtools}
\usepackage{cases}
\usepackage{centernot}
\usepackage[makeroom]{cancel}
\usepackage{graphics,graphicx}
\graphicspath{ {images/} }
\usepackage[a4paper,width=170mm,top=25mm,bottom=25mm]{geometry}
\usepackage{setspace}
\usepackage{float}
\usepackage[svgnames]{xcolor}
\usepackage{tikz,pgfplots,tikz-3dplot}
\usepackage{xfrac}
\usepackage{multirow,multicol}
\usepackage{physics}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{bbm}
\usepackage[toc]{appendix}
\usepackage{parskip}
\usepackage{tikz-cd}
\usepackage{ifthen}
\usepackage{xstring}
\usepackage{witharrows}
\usepackage[scr=boondox, cal=esstix]{mathalpha}
\usepackage{listings}

% python code stuff

% check this link for explanation:
% https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

% i don't know why this new environment doesn't work

%\newcommand{\pycode}[1]{
%	\begin{lstlisting}[language=Python]
%		#1
%	\end{lstlisting}
%}

% symbols definition

\newcommand{\Ld}{\mathcal{L}}
\newcommand{\Hd}{\mathcal{H}}
\renewcommand{\grad}[1]{\va{\boldsymbol{\nabla}}{#1}}
\renewcommand{\curl}[1]{\va{\boldsymbol{\nabla}} \wedge{#1}}
\newcommand{\bigo}[1]{\mathcal{O} \! \left( #1 \right)}
\newcommand{\smo}[1]{\mathcal{o} \! \left( #1 \right)}
\newcommand{\lnab}[1]{\ln \abs{#1}}

\newcommand{\id}{\operatorname{id}}
\newcommand{\bigone}{\mathbbm{1}}
\newcommand{\sgn}[1]{\operatorname{sgn} \left( #1 \right)}
\newcommand{\diag}[1]{\operatorname{diag} \left( #1 \right)}
\newcommand{\supp}{\operatorname{supp}}
\newcommand{\ob}{\operatorname{Ob}}
\newcommand{\mor}{\operatorname{Mor}}
\newcommand{\st}{\, \middle| \,}
\newcommand{\hatapp}{\; \hat{} \;}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

%\newcommand{\ie}{i.e. \phantom{$ \!\! $}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\T}{\mathbb{T}}
\renewcommand{\S}{\mathbb{S}}

\newcommand{\rp}[1]{\R\mathcal{P}^{#1}}
\newcommand{\B}{\mathcal{B}}

%\newcommand{\g}{\mathfrak{g}}
%\newcommand{\h}{\mathfrak{h}}
%\newcommand{\so}{\mathfrak{so}}
%\newcommand{\su}{\mathfrak{su}}

\newcommand{\notimplies}{\centernot\implies}
\newcommand{\E}{\exists \;}
\newcommand{\ps}{\mathcal{P}}

\newcommand{\hal}{\hspace{13px}}

\DeclareDocumentCommand\dpdv{}{\displaystyle\partialderivative}
\DeclareDocumentCommand\ddv{}{\displaystyle\derivative}

% bracket under equations for explanations

\definecolor{explcol}{RGB}{0, 191, 255} % light blue

\newcommand{\expl}[2]{
	\textcolor{explcol}{ %
		\underbracket[.65pt][4.5pt]{ \textcolor{black}{#2} }_{ \mathclap{ \textcolor{explcol}{#1} } } %
	} %
}

% subequations + align + side arrows environment

% mind this link for explanation of if statement
% https://tex.stackexchange.com/a/314/86

% use this to shift back up the first line
% \vspace{-2.1em}

\makeatletter
\def\subeq{\@ifnextchar[{\@with}{\@without}}
\def\@with[#1]#2{
	\begin{DispWithArrows}[subequations, displaystyle, wrap-lines]
		& \label{#1} \tag{\theequation} \\
		#2
	\end{DispWithArrows}
}
\def\@without#1{
	\begin{DispWithArrows}[subequations, displaystyle, wrap-lines]
		#1
	\end{DispWithArrows}
}
\makeatother

% map definition

\newcommand{\map}[5]{
	\begin{align}
		\begin{split}
			#1 : #2 &\to #3 \\
			#4 &\mapsto #5
		\end{split}
	\end{align}
}

% map w/o equation number

\newcommand{\maps}[5]{
	\begin{align*}
		\begin{split}
			#1 : #2 &\to #3 \\
			#4 &\mapsto #5
		\end{split}
	\end{align*}
}

% image definition

\newcommand{\img}[2]{
	\begin{figure}[H]
		\centering
		\includegraphics[width=#1\textwidth,keepaspectratio]{#2}
	\end{figure}
}

% diagram definition

% mind this link for why & -> \&:
% https://tex.stackexchange.com/questions/15093/single-ampersand-used-with-wrong-catcode-error-using-tikz-matrix-in-beamer

\newcommand{\diagr}[1]{
	\begin{figure}[H]
		\centering
		\begin{tikzcd}[ampersand replacement=\&]
			#1
		\end{tikzcd}
	\end{figure}
}

% side-by-side (two neighbouring boxes)

% \sbs{[width left box]}{[content left box]}{[width right box]}{[content right box]}

\newcommand{\sbs}[4]{
	\noindent\begin{minipage}[c]{#1\textwidth}
		#2
	\end{minipage}
	\begin{minipage}[c]{#3\textwidth}
		#4
	\end{minipage}
}

%

% exercise macro

%\newcounter{solutions}
%\setcounter{solutions}{42} % change this number from 42 to whatever to hide solutions

% \exer{[title]}{[label]}{[exercise text]}{[solution]}

%\newcommand{\exer}[4]{
%	\section{Esercizio #1}\label{#2}
%	
%	\begin{tcolorbox}
%		#3
%	\end{tcolorbox}
%	
%	\ifthenelse{\thesolutions = 42}
%	{#4}
%	{}
%	
%	%
%	
%	\newpage
%}

%

\renewcommand{\contentsname}{Indice}

\makeatletter
\renewcommand{\@chapapp}{Capitolo}
\makeatother

% environments names

\newtheorem{theorem}{Teorema}
\newtheorem{corollary}{Corollario}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{remark}{Osservazione}
\newtheorem{definition}{Definizione}[theorem]
\newtheorem{proposition}{Proposizione}[theorem]

\renewcommand*{\proofname}{Dimostrazione}
\renewcommand\qedsymbol{$\square$}

% \highlight[<colour>]{<stuff>}

\newcommand{\highlight}[2][yellow]{\mathchoice%
	{\colorbox{#1}{$\displaystyle#2$}}%
	{\colorbox{#1}{$\textstyle#2$}}%
	{\colorbox{#1}{$\scriptstyle#2$}}%
	{\colorbox{#1}{$\scriptscriptstyle#2$}}}%

% hlc = highlight colour

\definecolor{hlc1}{RGB}{204,241,202} % green
\definecolor{hlc2}{RGB}{255,143,188} % pink
\definecolor{hlc3}{RGB}{163,209,255} % light blue

\newcommand{\hl}[2]{%
	\IfEqCase{#1}{%
		{1}{\highlight[hlc1]{#2}}%
		{2}{\highlight[hlc2]{#2}}%%
		{3}{\highlight[hlc3]{#2}}%
		% can add more cases here as desired
	}[\PackageError{choosecolour}{Undefined option to hl: #1}{}]%
}

% blue links for footsnotes and references

\usepackage[
bookmarksnumbered = true,
linktocpage = true
]{hyperref}

\hypersetup{
	colorlinks = true,
	linkcolor = blue,
	anchorcolor = blue,
	citecolor = blue,
	filecolor = blue,
	urlcolor = blue
}

\begin{document}
	
% titolo

\begin{center}
	{\Large
		\textbf{Esercitazione 1} \\
			Elettrodinamica relativistica \\
			A.A. 2023/2024 \\
			\vspace{0.7cm}
			\textit{Simone Iovine}
		}
\end{center}

\vspace{2cm}

%

\section*{Esercizio 1}

Riscriviamo la definizione della rapidità

\begin{equation}
	y \doteq \dfrac{1}{2} \ln(\dfrac{E + c p_{z}}{E - c p_{z}}) %
	= \dfrac{1}{2} \ln(\dfrac{1 + \dfrac{v_{z}}{c}}{1 - \dfrac{v_{z}}{c}})
\end{equation}

nel seguente modo

\begin{equation}
	e^{2 y} = \dfrac{E + c p_{z}}{E - c p_{z}} %
	= \dfrac{1 + \dfrac{v_{z}}{c}}{1 - \dfrac{v_{z}}{c}}
\end{equation}

definendo

\begin{equation}
	\beta \doteq \dfrac{u}{c}
\end{equation}

dove $u$ è la velocità del boost, abbiamo anche

\begin{equation}
	e^{2 \eta} = \dfrac{1 + \beta}{1 - \beta}
\end{equation}

Considerando il 4-momento

\begin{equation}
	\va{p} = (E, c \va{p}) %
	= (E, c p_{x}, c p_{y}, c p_{z})
\end{equation}

un boost lungo $z$ può essere calcolato tramite la matrice

\begin{equation}
	\Lambda = \bmqty{\gamma & 0 & 0 & - \beta \gamma \\
					0 & 1 & 0 & 0 \\
					0 & 0 & 1 & 0 \\
					- \beta \gamma & 0 & 0 & \gamma}
\end{equation}

dunque

\begin{equation}
	\va{p}' = \Lambda \va{p}
\end{equation}

Le componenti che hanno subito un cambiamento saranno

\begin{equation}
	\begin{cases}
		E' = \gamma (E - \beta c p_{z}) \\
		c p_{z}' = \gamma (c p_{z} - \beta E)
	\end{cases}
\end{equation}

Siccome i fasci sono incidenti, operiamo il cambiamento di segno $\beta \to - \beta$, da cui

\begin{equation}
	\begin{cases}
		E' = \gamma (E + \beta c p_{z}) \\
		c p_{z}' = \gamma (c p_{z} + \beta E)
	\end{cases}
\end{equation}

A questo punto consideriamo la rapidità nel sistema di riferimento primato

\subeq{
	e^{2 y'} &= \dfrac{E' + c p_{z}'}{E' - c p_{z}'} \\\\
	&= \dfrac{\gamma (E + \beta c p_{z}) + \gamma (c p_{z} + \beta E)}{\gamma (E + \beta c p_{z}) - \gamma (c p_{z} + \beta E)} \\\\
	&= \dfrac{E + \beta c p_{z} + c p_{z} + \beta E}{E + \beta c p_{z} - c p_{z} - \beta E} \\\\
	&= \dfrac{E + \beta c p_{z} + \beta (E + c p_{z})}{E - \beta c p_{z} - \beta (E - c p_{z})} \\\\
	&= \expl{e^{2 y}}{\dfrac{E + c p_{z}}{E - c p_{z}}} \, \expl{e^{2 \eta}}{\dfrac{1 + \beta}{1 - \beta}} \\
	&= e^{2(y + \eta)}
}

\begin{equation}
	e^{2 y'} = e^{2 y'} e^{2 \eta} %
	\implies %
	y'= y + \eta
\end{equation}

Analogamente, si può trovare la stessa soluzione usando la seconda definizione della rapidità. Consideriamo ancora il boost in $z$ della 4-posizione

\begin{equation}
	\begin{cases}
		\va{x} = (c t, \va{x}) \\
		\va{x}' = \Lambda \va{x}
	\end{cases}
\end{equation}

\begin{equation}
	\begin{cases}
		c t' = \gamma (c t - \beta z) \\
		z' = \gamma (z - \beta c t)
	\end{cases}
\end{equation}

da questi possiamo derivare la velocità nel sistema di riferimento primato

\begin{equation}
	\dfrac{v_{z}'}{c} = \dfrac{z'}{c t'} %
	= \dfrac{z - \beta c t}{c t - \beta z} %
	= \dfrac{c t}{c t} \dfrac{\dfrac{z}{ct} - \beta}{1 - \beta \dfrac{z}{ct}} %
	= \dfrac{\dfrac{v_{z}}{c} - \beta}{1 - \beta \dfrac{v_{z}}{c}}
\end{equation}

Ancora una volta, siccome i fasci sono incidenti, operiamo il cambiamento di segno $\beta \to - \beta$, da cui

\begin{equation}
	\dfrac{v_{z}'}{c} = \dfrac{\dfrac{v_{z}}{c} + \beta}{1 + \beta \dfrac{v_{z}}{c}}
\end{equation}

A questo punto sostituiamo nella definizione della rapidità

\subeq{
	e^{2 y'} &= \dfrac{1 + \dfrac{v_{z}'}{c}}{1 - \dfrac{v_{z}'}{c}} \\
	&= \dfrac{1 + \dfrac{\dfrac{v_{z}}{c} + \beta}{1 + \beta \dfrac{v_{z}}{c}}}{1 - \dfrac{\dfrac{v_{z}}{c} + \beta}{1 + \beta \dfrac{v_{z}}{c}}} \\
	&= \dfrac{1 + \beta \dfrac{v_{z}}{c} + \dfrac{v_{z}}{c} + \beta}{1 + \beta \dfrac{v_{z}}{c} - \dfrac{v_{z}}{c} - \beta} \\
	&= \dfrac{1 + \beta + \dfrac{v_{z}}{c} (1 + \beta)}{1 - \beta - \dfrac{v_{z}}{c} (1 - \beta)} \\
	&= \expl{e^{2 y}}{ \dfrac{1 + \dfrac{v_{z}}{c}}{1 - \dfrac{v_{z}}{c}}} \, \expl{e^{2 \eta}}{\dfrac{1 + \beta}{1 - \beta}} \\
	&= e^{2(y + \eta)}
}

\begin{equation}
	e^{2 y'} = e^{2 y'} e^{2 \eta} %
	\implies %
	y'= y + \eta
\end{equation}

% ==============================================================================

\section*{Esercizio 2}

Riscriviamo la formula per la sezione d'urto nel seguente modo

\begin{equation}
	\sigma = \dfrac{\dd{\nu}}{\dd{V} \dd{t}} \, \dfrac{1}{v_{rel} \, n_{1} \, n_{2}}
\end{equation}

Tutte le quantità riportate in questa formula sono misurate nel sistema di riferimento del laboratorio, il quale è solidale anche al bersaglio di densità $n_{2}$. \\
Sfruttando i fenomeni di dilatazione del tempo e contrazione delle lunghezze, possiamo riscrivere le quantità riportate nella formula nel sistema di riferimento solidale al fascio incidente di densità $n_{1}$:

\begin{equation}
	\begin{dcases}
		\dd{\nu}' = \dd{\nu} \\
		\dd{V}' = \dfrac{1}{\gamma} \, \dd{V} \\
		\dd{t}' = \gamma \dd{t} \\
		n_{1}' = \dfrac{1}{\gamma} \, n_{1} \\
		n_{2}' = \gamma \, n_{2}
	\end{dcases}
\end{equation}

questo perché:

\begin{itemize}
	\item il numero di urti $\dd{\nu}$ rimane costante indipendentemente dal sistema di riferimento considerato,
	
	\item il volume considerato dove si contano gli urti appare contratto per un osservatore solidale con il fascio in movimento a causa della velocità relativa,
	
	\item per lo stesso motivo, l'intervallo di tempo di misura appare dilatato,
	
	\item la densità di particelle del fascio incidente diminuisce in quanto il volume in cui questa viene calcolata è più grande rispetto al volume misurato nel sistema di riferimento solidale al laboratorio (il quale appare contratto a causa del movimento del fascio incidente rispetto al laboratorio), 
	
	\item la densità di particelle del bersaglio invece aumenta per lo stesso motivo.
\end{itemize}

A questo punto, sostituendo le quantità calcolate nel sistema di riferimento solidale con il fascio incidente nella formula per la sezione d'urto calcolata in questo sistema, otteniamo

\begin{equation}
	\sigma' = \dfrac{\dd{\nu}'}{\dd{V}' \dd{t}'} \, \dfrac{1}{v_{rel} \, n_{1}' \, n_{2}'} %
	= \dfrac{\dd{\nu}}{\dfrac{1}{\gamma} \, \dd{V} \gamma \, \dd{t}'} \, \dfrac{1}{v_{rel} \, \dfrac{1}{\gamma} \, n_{1} \, \gamma \, n_{2}'} %
	= \sigma
\end{equation}

% ==============================================================================

\section*{Esercizio 3}

\subsection*{Equazione del moto}

Consideriamo la seconda legge di Newton

\begin{equation}
	\va{F} = \dv{\va{p}}{t}
\end{equation}

dove il momento relativistico è pari a

\begin{equation}
	\va{p} = m \gamma \va{v}
\end{equation}

Prendendo solo i moduli dei vettori considerati e ricordando che la forza considerata è costante, integriamo la seconda legge di Newton

\subeq{
	\int_{0}^{t} \dv{(m \gamma v)}{\xi} \dd{\xi} &= \int_{0}^{t} F \dd{\xi} \\
	\dfrac{m v}{\sqrt{1 - \dfrac{v^{2}}{c^{2}}}} &= F t \\
	\dfrac{m^{2} v^{2}}{1 - \dfrac{v^{2}}{c^{2}}} &= F^{2} t^{2} \\
	\dfrac{m^{2} c^{2}}{c^{2} - v^{2}} \, v^{2} &= F^{2} t^{2} \\
	\dfrac{m^{2} c^{2}}{F^{2} t^{2}} \, v^{2} &= c^{2} - v^{2} \\
	\left( \dfrac{m^{2} c^{2}}{F^{2} t^{2}} + 1 \right) v^{2} &= c^{2} \\
	v &= \dfrac{c}{\sqrt{ 1 + \dfrac{m^{2} c^{2}}{F^{2} t^{2}}} } \\
	&= \dfrac{c}{\sqrt{\dfrac{F^{2} t^{2} + m^{2} c^{2}}{F^{2} t^{2}}} } \\
	&= \dfrac{c F t}{\sqrt{ F^{2} t^{2} + m^{2} c^{2} }} \\
	&= \dfrac{c}{m c} \dfrac{F t}{\sqrt{ 1 + \dfrac{F^{2} t^{2}}{m^{2} c^{2}} }}\\
	&= \dfrac{F t}{m} \left( 1 + \dfrac{F^{2} t^{2}}{m^{2} c^{2}} \right)^{- 1/2}
}

Integrando ancora la velocità e ponendo $x(t=0)=0$,

\subeq{
	\int_{0}^{t} v(\xi) \dd{\xi} &= \dfrac{F}{m} \int_{0}^{t} \xi \left( 1 + \dfrac{F^{2} \xi^{2}}{m^{2} c^{2}} \right)^{- 1/2} \dd{\xi} \\
	x &= \dfrac{F}{m} \left[ \dfrac{m^{2} c^{2}}{F^{2}} \left( 1 + \dfrac{F^{2} \xi^{2}}{m^{2} c^{2}} \right)^{1/2} \right]_{0}^{t} \\
	&= \dfrac{m c^{2}}{F} \left( 1 + \dfrac{F^{2} t^{2}}{m^{2} c^{2}} \right)^{1/2} - \dfrac{m c^{2}}{F}
}

da cui otteniamo l'equazione del moto

\begin{equation}
	x(t) = \dfrac{m c^{2}}{F} \left( \sqrt{1 + \dfrac{F^{2}}{m^{2} c^{2}} \, t^{2}} - 1 \right)
\end{equation}

\subsection*{Formula per l'accelerazione}

Poniamo che la velocità $\beta \doteq u / c$ sia limitata all'asse $z$, dunque la trasformazione è data da

\begin{equation}
	\begin{cases}
		c \dd{t}' = \gamma (c \dd{t} - \beta \dd{z}) \\
		\dd{z}' = \gamma (\dd{z} - \beta c \dd{t})
	\end{cases}
\end{equation}

da questi possiamo derivare la velocità $v$ nel sistema di riferimento primato $v'$ come

\begin{equation}
	v' = c \, \dfrac{\dd{z}'}{c \dd{t}'} %
	= c \, \dfrac{\dd{z} - \beta c \dd{t}}{c \dd{t} - \beta \dd{z}} %
	= c \, \dfrac{c \dd{t}}{c \dd{t}} \dfrac{\dfrac{\dd{z}}{c \dd{t}} - \beta}{1 - \beta \dfrac{\dd{z}}{c \dd{t}}} %
	= c \, \dfrac{\dfrac{v}{c} - \beta}{1 - \beta \dfrac{v}{c}} %
	= \dfrac{v - \beta c}{1 - \beta \dfrac{v}{c}}
\end{equation}

Usando

\begin{equation}
	\gamma \doteq \dfrac{1}{\sqrt{1 - \beta^{2}}} %
	\implies %
	1 - \beta^{2} = \dfrac{1}{\gamma^{2}}
\end{equation}

calcoliamo il differenziale della velocità

\subeq{
	\dd{v}' &= \dd{(v - \beta c)} \dfrac{1}{1 - \beta \dfrac{v}{c}} + (v - \beta c) \dd{\left( \dfrac{1}{1 - \beta \dfrac{v}{c}} \right)} \\
	&= \dfrac{\dd{v}}{1 - \beta \dfrac{v}{c}} + (v - \beta c) \left( - \dfrac{1}{\left(1 - \beta \dfrac{v}{c}\right)^{2}} \right) \left( - \dfrac{\beta}{c} \dd{v} \right) \\
	&= \left( \dfrac{1}{1 - \beta \dfrac{v}{c}} + \dfrac{\left( \dfrac{v}{c} - \beta \right) \beta}{\left(1 - \beta \dfrac{v}{c}\right)^{2}} \right) \dd{v} \\
	&= \dfrac{1 - \beta \dfrac{v}{c} + \beta \dfrac{v}{c} - \beta^{2}}{\left(1 - \beta \dfrac{v}{c}\right)^{2}} \dd{v} \\
	&= \dfrac{1}{\gamma^{2} \left(1 - \beta \dfrac{v}{c}\right)^{2}} \dd{v}
}

A questo punto possiamo calcolare l'accelerazione

\subeq{
	a' &\doteq \dv{v'}{t'} \\
	&= \dfrac{\dd{v}}{\gamma^{2} \left(1 - \beta \dfrac{v}{c}\right)^{2}} \dfrac{c}{\gamma (c \dd{t} - \beta \dd{z})} \\
	&= \dfrac{c}{\gamma^{3} \left(1 - \beta \dfrac{v}{c}\right)^{2} (c \dd{t} - \beta \dd{z})} \dd{v} \\
	&= \dfrac{c}{\gamma^{3} \left(1 - \beta \dfrac{v}{c}\right)^{2} c \dd{t} \left(1 - \beta \expl{v/c}{\dfrac{\dd{z}}{c \dd{t}}}\right)} \dd{v} \\
	&= \dfrac{1}{\gamma^{3} \left(1 - \beta \dfrac{v}{c}\right)^{3}} \dv{v}{t} \\
	&= \dfrac{1}{\gamma^{3} \left(1 - \beta \dfrac{v}{c}\right)^{3}} \, a
}

Essendo la velocità del boost la stessa della velocità di cui abbiamo operato la trasformazione, i.e. $\beta = v/c$, otteniamo

\begin{equation}\label{eq:acc-gamma3}
	a' = \gamma^{3} a
\end{equation}

\subsection*{Accelerazione di un protone}

Integriamo ora l'Equazione \ref{eq:acc-gamma3} nel tempo, considerando costante l'accelerazione $a'$

\subeq{
	\int_{0}^{t} a' \dd{\xi} &= \int_{0}^{t} \gamma^{3} a \dd{\xi} \\
	a' t &= \int_{0}^{t} \gamma^{3} \dv{v}{\xi} \dd{\xi} \\
	&= \int_{0}^{v} \left( 1 - \dfrac{w^{2}}{c^{2}} \right)^{- 3/2} \dd{w} %
		\Arrow{$w \doteq c \sin(\phi)$ \\ $\dd{w} = c \cos(\theta) \dd{\theta}$} 
		\\
	&= \int_{\tau / 2}^{\asin(v/c)} \left( 1 - \sin[2](\theta) \right)^{- 3/2} c \cos(\theta) \dd{\theta} \\
	&= \int_{\tau / 2}^{\asin(v/c)} \dfrac{\cos(\theta)}{\cos[3](\theta)} \dd{\theta} \\
	&= c \int_{\tau / 2}^{\asin(v/c)} \dfrac{1}{\cos[2](\theta)} \dd{\theta} \\
	&= c \left[ \tan(\theta) \right]_{\tau / 2}^{\asin(v/c)} \\
	&= c \tan(\asin(\dfrac{v}{c})) \\
	&= v \left( 1 - \dfrac{v^{2}}{c^{2}} \right)^{- 1/2} \\
	(a' t)^{2} \left( 1 - \dfrac{v^{2}}{c^{2}} \right) &= v^{2} \\
	v^{2} - (a' t)^{2} \dfrac{v^{2}}{c^{2}} &= (a' t)^{2} \\
	v &= \dfrac{a' t}{\sqrt{ 1 + \left( \dfrac{a' t}{c} \right)^{2} }}\label{eq:vel-acc}
}


Sostituiamo ora l'Equazione \ref{eq:vel-acc} nella formula per l'energia relativistica, esplicitando il tempo

\subeq{
	\mathcal{E} &= m \gamma c^{2} \\
	&= m c^{2} \left( 1 - \dfrac{v^{2}}{c^{2}} \right)^{- 1/2} \\
	1 - \dfrac{v^{2}}{c^{2}} &= \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \\
	v^{2} &= c^{2} \left( 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \right) \\
	\dfrac{a'^{2} t^{2}}{ 1 + \dfrac{a'^{2}}{c^{2}} \, t^{2} } &= c^{2} \left( 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \right) \\
	\dfrac{a'^{2}}{c^{2}} \, t^{2} &= \left( 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \right) \left( 1 + \dfrac{a'^{2}}{c^{2}} \, t^{2} \right) \\
	\cancel{\dfrac{a'^{2}}{c^{2}} \, t^{2}} &= 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} + \cancel{\dfrac{a'^{2}}{c^{2}} \, t^{2}} - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \dfrac{a'^{2}}{c^{2}} \, t^{2} \\
	\dfrac{m^{2} c^{2} a'^{2}}{\mathcal{E}^{2}} \, t^{2} &= 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} \\
	t &= \dfrac{\mathcal{E}}{m c a'} \sqrt{ 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} }
}

Ricordando che

\begin{gather}
	F = m \gamma^{3} a = m a' = e E \\
	\nonumber \\
	\operatorname{\dfrac{V}{m}} = \operatorname{\dfrac{N}{C}} = 6.2 \cdot 10^{9} \operatorname{\dfrac{GeV}{m}}
\end{gather}

Sostituendo i dati

\begin{equation}
	\begin{dcases}
		\mathcal{E} = 1 \operatorname{TeV} = 10^{3} \operatorname{GeV} \\
		m = 1 \operatorname{\dfrac{GeV}{c^{2}}} \\
		E = 1 \operatorname{\dfrac{V}{m}} = 6.2 \cdot 10^{9} \operatorname{\dfrac{GeV}{m}} \\
		e = 1.6 \cdot 10^{-19} \operatorname{C} \\
		c = 3 \cdot 10^{8} \operatorname{\dfrac{m}{s}}
	\end{dcases}
\end{equation}

otteniamo

\subeq{
	t &= \dfrac{\mathcal{E}}{m c a'} \sqrt{ 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} } \\
	&= \dfrac{\mathcal{E}}{e c E} \sqrt{ 1 - \dfrac{m^{2} c^{4}}{\mathcal{E}^{2}} } \\
	&= \expl{secondi}{\dfrac{ 10^{3} \operatorname{GeV} }{ (1.6 \cdot 10^{-19} \operatorname{C}) \left( 3 \cdot 10^{8} \operatorname{\dfrac{m}{s}} \right) \left( 6.2 \cdot 10^{9} \operatorname{\dfrac{GeV}{m}} \right) }} \expl{adimensionale}{\sqrt{ 1 - \dfrac{ 1 \operatorname{\dfrac{GeV^{2}}{c^{4}}} c^{4} }{ 10^{6} \operatorname{GeV^{2}} } }}
}

il quale espresso in minuti e secondi risulta

\begin{equation}
	t \simeq 55 \operatorname{m} 35 \operatorname{s} 
\end{equation}

% ==============================================================================

\section*{Esercizio 4}

Il linguaggio scelto per questo esercizio è Python. \\
Importiamo \lstinline|numpy| per la radice quadrata, il prodotto matriciale, il generatore di numeri casuali e le matrici diagonali. Tramite quest'ultima, definiamo il tensore metrico \lstinline|eta|.

\begin{lstlisting}[language=Python]
		# packages import
		
		import numpy as np
		
		# true random generator
		
		rand = np.random.default_rng()
		
		# metric tensor
		
		eta = np.diag([1, -1, -1, -1])
\end{lstlisting}

Di seguito la definizione delle funzioni che saranno utili nella definizione delle classi e nel codice stesso. Nello specifico:

\begin{description}
	\item[dot] prodotto matriciale
	
	\item[mod] modulo di un 3-vettore
	
	\item[dotLor] prodotto di due vettori (entrambi covarianti o controvarianti), intramezzato dal tensore metrico per abbassare/sollevare uno degli indici
	
	\item[g] fattore di Lorentz
	
	\item[rnd3Vel] generatore di un 3-vettore con entrate casuali, normalizzato in unità di $c$, velocità della luce
	
	\item[rnd4Vec] generatore di un 4-vettore con entrate casuali nell'intervallo $(-10,10)$
	
	\item[lorTransf] generatore di una boost di Lorentz in nella direzione della velocità inserita come argomento
	
	\item[printMatrix] funzione per stampare nel terminale le matrici in modo più leggibile
\end{description}

\begin{lstlisting}[language=Python]
	def dot(m1,m2):
		# dot product
		return np.dot(m1,m2)
	
	# ---
	
	def mod(vec):
		# module of a 3-vector
		return np.sqrt(sum(x ** 2 for x in vec))
	
	# ---
	
	def dotLor(vec1, vec2):
		# squared module of a 4-vector
		return dot(dot(vec1, eta), vec2)
	
	# ---
	
	def g(v):
		# gamma factor for the velocity v
		return 1 / np.sqrt(1 - mod(v) ** 2)
	
	# ---
	
	def rnd3Vel():
		# generate a random 3-velocity (c = 1)
		vel = 20*rand.random(3) - 10
		vel /= mod(vel) / rand.random()
		return vel
	
	# ---
	
	def rnd4Vec(minVal, maxVal):
		# generate a random 4-vector with entries in (minVal, maxVal)
		vec = (maxVal - minVal)*rand.random(4) + minVal
		return vec
	
	# ---
	
	def lorTransf(v):
	# generate a Lorentz boost matrix with velocity given by v
		B = [ [ g(v), - g(v) * v[0], - g(v) * v[1], - g(v) * v[2] ],
		[ - g(v) * v[0], 1 + (g(v) - 1) * (v[0]  / mod(v)) ** 2, \
		(g(v) - 1) * (v[0] * v[1]  / mod(v) ** 2), \
		(g(v) - 1) * (v[0] * v[2]  / mod(v) ** 2) ],
		[ - g(v) * v[1], (g(v) - 1) * (v[1] * v[0]  / mod(v) ** 2), \
		1 + (g(v) - 1) * (v[1]  / mod(v)) ** 2, \
		(g(v) - 1) * (v[1] * v[2]  / mod(v) ** 2) ],
		[ - g(v) * v[2], (g(v) - 1) * (v[2] * v[0]  / mod(v) ** 2), \
		(g(v) - 1) * (v[2] * v[1]  / mod(v) ** 2), \
		1 + (g(v) - 1) * (v[2]  / mod(v)) ** 2 ] ]
		return B
	
	# ---
	
	def printMatrix(matrix):
		for lst in matrix:
			for element in lst:
				print("{:10.6f}".format(element), end="\t")
			print("")
\end{lstlisting}

A questo punto, definiamo le due classi che ci serviranno per la soluzione: un vettore di Lorentz e un boost di Lorentz. Entrambi vengono generati casualmente se non viene dato loro come argomento un 4-vettore o una 3-velocità rispettivamente, seguito dal comando \lstinline|rnd=False|.

\begin{description}
	\item[lorVec] un vettore di Lorentz con entrate modificabili, modulo e tipo (luce, tempo, spazio)
	
	\item[boost] un boost di Lorentz con entrate modificabili e velocità su cui è calcolato il boost disponibile
\end{description}

\begin{lstlisting}[language=Python]
	class lorVec:
	
		'''Lorentz vector with entries, module, and squared module'''
		
		def __init__(self, *vec, **check):
			self.vec = rnd4Vec(-10, 10) if check.get('rnd', True) else list(*vec)
			self.mod = dotLor(self.vec, self.vec)
		
			if self.mod == 0:
				self.vecType = 'light'
			elif self.mod > 0:
				self.vecType = 'time'
			else:
				self.vecType = 'space'
	
	# ---
	
	class boost:
	
		'''Lorentz boost, with matrix and versor'''
		
		def __init__(self, *vel, **check):
			self.vel = rnd3Vel() if check.get('rnd', True) else list(*vel)
			self.boostMatrix = lorTransf(self.vel)
\end{lstlisting}

Nella parte principale del codice generiamo tre vettori (due casuali e uno fisso)

\begin{lstlisting}[language=Python]
	u = lorVec()
	v = lorVec()
	
	vec = [1,1,1,0]
	w = lorVec(vec, rnd=False)
\end{lstlisting}

Ne calcoliamo il prodotto scalare

\begin{lstlisting}[language=Python]
	uv = dotLor(u.vec, v.vec)
	uw = dotLor(u.vec, w.vec)
	vw = dotLor(v.vec, w.vec)
\end{lstlisting}

Generiamo due boost (uno casuale e uno fisso generato da una velocità sull'asse $z$)

\begin{lstlisting}[language=Python]
	B = boost()
	
	vel = [0, 0, 0.9]
	C = boost(vel, rnd=False)
\end{lstlisting}

Facciamo agire i boost sui vettori definiti in precedenza

\begin{lstlisting}[language=Python]
	Bu = dot(B.boostMatrix, u.vec)
	Bv = dot(B.boostMatrix, v.vec)
	Bw = dot(B.boostMatrix, w.vec)
	
	Cu = dot(C.boostMatrix, u.vec)
	Cv = dot(C.boostMatrix, v.vec)
	Cw = dot(C.boostMatrix, w.vec)
\end{lstlisting}

e calcoliamo i prodotti dei vettori in seguito ai boost

\begin{lstlisting}[language=Python]
	BuBv = dotLor(Bu, Bv)
	BuBw = dotLor(Bu, Bw)
	BvBw = dotLor(Bv, Bw)
	
	CuCv = dotLor(Cu, Cv)
	CuCw = dotLor(Cu, Cw)
	CvCw = dotLor(Cv, Cw)
\end{lstlisting}

A questo punto possiamo calcolare semplicemente le differenze tra i prodotti scalari prima e dopo i boost:

\begin{verbatim}
	VECTORS DECLARATIONS
	
	random vector u:
	
	u =  [-6.11635617 -8.01803261  3.43250309  6.35179459] 
	module =  -79.00640609375716 
	type =  space
	
	random vector v:
	
	v =  [ 8.8227775  -4.49636568  6.24238156  8.14558065] 
	module =  -47.6937131194255 
	type =  space
	
	fixed vector w:
	
	w =  [1, 1, 1, 0] 
	module =  -1 
	type =  space
	
	INNER PRODUCTS BETWEEN VECTORS
	
	u v =  -163.18130540548972
	u w =  -1.530826658809973
	v w =  7.076761622107156
	
	RANDOM AND FIXED BOOST DECLARATIONS
	
	random boost B:
	
	boost velocity =  [ 0.13380972 -0.14730109  0.26939327] 
	boost velocity module =  0.33492594285180055
	boost matrix =
	1.061296	 -0.142012	  0.156330	 -0.285906	
	-0.142012	  1.009784	 -0.010770	  0.019697	
	0.156330	 -0.010770	  1.011856	 -0.021683	
	-0.285906	  0.019697	 -0.021683	  1.039656	
	
	fixed boost C:
	
	boost velocity =  [0, 0, 0.9] 
	boost velocity module =  0.9
	boost matrix =
	2.294157	 -0.000000	 -0.000000	 -2.064742	
	-0.000000	  1.000000	  0.000000	  0.000000	
	-0.000000	  0.000000	  1.000000	  0.000000	
	-2.064742	  0.000000	  0.000000	  2.294157	
	
	BOOSTING VECTORS
	
	boost via B:
	
	B u =  [-6.63202075 -7.13974113  2.46565788  8.12002052]
	B v =  [ 8.64911418 -5.70008076  7.56746121  5.72219358]
	B w =  [ 1.07561404  0.85700186  1.15741592 -0.28789191]
	
	boost via C:
	
	C u =  [-27.14669796  -8.01803261   3.43250309  27.20071123]
	C v =  [ 3.42232049 -4.49636568  6.24238156  0.47048784]
	C w =  [ 2.29415734  1.          1.         -2.0647416 ]
	
	INNER PRODUCTS BETWEEN BOOSTED VECTORS
	
	B u B v =  -163.18130540548972
	B u B w =  -1.5308266588099717
	B v B w =  7.076761622107155
	
	C u C v =  -163.1813054054897
	C u C w =  -1.5308266588099713
	C v C w =  7.0767616221071545
	
	COMPARISON BETWEEN INNER PRODUCTS BEFORE AND AFTER BOOST
	
	B u B v - u v = 0.000
	B u B w - u w = 0.000
	B v B w - v w = -0.000
	
	C u C v - u v = 0.000
	C u C w - u w = 0.000
	C v C w - v w = -0.000
\end{verbatim}

Queste risultano tutte nulle come ci si aspetta in quanto il prodotto scalare è un invariante di Lorentz.

% ==============================================================================

\section*{Codice completo}

\begin{verbatim}
	# =============================================================================
	# EXERCISE 1-4
	# =============================================================================
	
	# the following exercise uses the convention:
	# c = 1
	
	# =============================================================================
	# packages import
	# =============================================================================
	
	import numpy as np
	
	# =============================================================================
	# constants definition
	# =============================================================================
	
	# true random generator
	
	rand = np.random.default_rng()
	
	# metric tensor
	
	eta = np.diag([1, -1, -1, -1])
	
	# =============================================================================
	# functions definition
	# =============================================================================
	
	def dot(m1,m2):
	# dot product
	return np.dot(m1,m2)
	
	# ---
	
	def mod(vec):
	# module of a 3-vector
	return np.sqrt(sum(x ** 2 for x in vec))
	
	# ---
	
	def dotLor(vec1, vec2):
	# squared module of a 4-vector
	return dot(dot(vec1, eta), vec2)
	
	# ---
	
	def g(v):
	# gamma factor for the velocity v
	return 1 / np.sqrt(1 - mod(v) ** 2)
	
	# ---
	
	def rnd3Vel():
	# generate a random 3-velocity (c = 1)
	vel = 20*rand.random(3) - 10
	vel /= mod(vel) / rand.random()
	return vel
	
	# ---
	
	def rnd4Vec(minVal, maxVal):
	# generate a random 4-vector with entries in (minVal, maxVal)
	vec = (maxVal - minVal)*rand.random(4) + minVal
	return vec
	
	# ---
	
	def lorTransf(v):
	# generate a Lorentz boost matrix with velocity given by v
	B = [ [ g(v), - g(v) * v[0], - g(v) * v[1], - g(v) * v[2] ],
	[ - g(v) * v[0], 1 + (g(v) - 1) * (v[0]  / mod(v)) ** 2, \
	(g(v) - 1) * (v[0] * v[1]  / mod(v) ** 2), \
	(g(v) - 1) * (v[0] * v[2]  / mod(v) ** 2) ],
	[ - g(v) * v[1], (g(v) - 1) * (v[1] * v[0]  / mod(v) ** 2), \
	1 + (g(v) - 1) * (v[1]  / mod(v)) ** 2, \
	(g(v) - 1) * (v[1] * v[2]  / mod(v) ** 2) ],
	[ - g(v) * v[2], (g(v) - 1) * (v[2] * v[0]  / mod(v) ** 2), \
	(g(v) - 1) * (v[2] * v[1]  / mod(v) ** 2), \
	1 + (g(v) - 1) * (v[2]  / mod(v)) ** 2 ] ]
	return B
	
	# ---
	
	def printMatrix(matrix):
	for lst in matrix:
	for element in lst:
	print("{:10.6f}".format(element), end="\t")
	print("")
	
	# =============================================================================
	# classes definition
	# =============================================================================
	
	class lorVec:
	
	'''Lorentz vector with entries, module, and squared module'''
	
	def __init__(self, *vec, **check):
	self.vec = rnd4Vec(-10, 10) if check.get('rnd', True) else list(*vec)
	self.mod = dotLor(self.vec, self.vec)
	
	if self.mod == 0:
	self.vecType = 'light'
	elif self.mod > 0:
	self.vecType = 'time'
	else:
	self.vecType = 'space'
	
	# ---
	
	class boost:
	
	'''Lorentz boost, with matrix and versor'''
	
	def __init__(self, *vel, **check):
	self.vel = rnd3Vel() if check.get('rnd', True) else list(*vel)
	self.boostMatrix = lorTransf(self.vel)
	
	# =============================================================================
	# actual code
	# =============================================================================
	
	print('======================================================================')
	print('OUTPUT')
	print('======================================================================')
	
	# generate two random vectors and one fixed
	
	print('VECTORS DECLARATIONS\n')
	
	print('random vector u:\n')
	
	u = lorVec()
	print('u = ', u.vec, '\nmodule = ', u.mod, '\ntype = ', u.vecType)
	
	print('\nrandom vector v:\n')
	
	v = lorVec()
	print('v = ', v.vec, '\nmodule = ', v.mod, '\ntype = ', v.vecType)
	
	print('\nfixed vector w:\n')
	
	vec = [1,1,1,0]
	
	w = lorVec(vec, rnd=False)
	print('w = ', w.vec, '\nmodule = ', w.mod, '\ntype = ', w.vecType)
	
	# inner products between 4-vectors
	
	print('\nINNER PRODUCTS BETWEEN VECTORS\n')
	
	uv = dotLor(u.vec, v.vec)
	uw = dotLor(u.vec, w.vec)
	vw = dotLor(v.vec, w.vec)
	
	print('u v = ', uv)
	print('u w = ', uw)
	print('v w = ', vw)
	
	# boost of v in random direction
	
	print('\nRANDOM AND FIXED BOOST DECLARATIONS\n')
	
	print('random boost B:\n')
	
	B = boost()
	print('boost velocity = ', B.vel, '\nboost velocity module = ', mod(B.vel))
	print('boost matrix =')
	printMatrix(B.boostMatrix)
	
	print('\nfixed boost C:\n')
	
	vel = [0, 0, 0.9]
	
	C = boost(vel, rnd=False)
	print('boost velocity = ', vel, '\nboost velocity module = ', mod(vel))
	print('boost matrix =')
	printMatrix(C.boostMatrix)
	
	# boosting vectors
	
	print('\nBOOSTING VECTORS\n')
	
	print('boost via B:\n')
	
	Bu = dot(B.boostMatrix, u.vec)
	Bv = dot(B.boostMatrix, v.vec)
	Bw = dot(B.boostMatrix, w.vec)
	
	print('B u = ', Bu)
	print('B v = ', Bv)
	print('B w = ', Bw)
	
	print('\nboost via C:\n')
	
	Cu = dot(C.boostMatrix, u.vec)
	Cv = dot(C.boostMatrix, v.vec)
	Cw = dot(C.boostMatrix, w.vec)
	
	print('C u = ', Cu)
	print('C v = ', Cv)
	print('C w = ', Cw)
	
	
	# inner products between boosted 4-vectors
	
	print('\nINNER PRODUCTS BETWEEN BOOSTED VECTORS\n')
	
	BuBv = dotLor(Bu, Bv)
	BuBw = dotLor(Bu, Bw)
	BvBw = dotLor(Bv, Bw)
	
	print('B u B v = ', BuBv)
	print('B u B w = ', BuBw)
	print('B v B w = ', BvBw)
	
	print()
	
	CuCv = dotLor(Cu, Cv)
	CuCw = dotLor(Cu, Cw)
	CvCw = dotLor(Cv, Cw)
	
	print('C u C v = ', CuCv)
	print('C u C w = ', CuCw)
	print('C v C w = ', CvCw)
	
	# comparison between inner products before and after boost
	
	print('\nCOMPARISON BETWEEN INNER PRODUCTS BEFORE AND AFTER BOOST\n')
	
	print('B u B v - u v = {:2.3f}'.format(BuBv - uv))
	print('B u B w - u w = {:2.3f}'.format(BuBw - uw))
	print('B v B w - v w = {:2.3f}'.format(BvBw - vw))
	
	print()
	
	print('C u C v - u v = {:2.3f}'.format(CuCv - uv))
	print('C u C w - u w = {:2.3f}'.format(CuCw - uw))
	print('C v C w - v w = {:2.3f}'.format(CvCw - vw))
	
	print('======================================================================')
	print('END OF OUTPUT')
	print('======================================================================')
	
\end{verbatim}
























\end{document}
